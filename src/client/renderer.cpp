#include "renderer.hpp"

#include <iostream>
#include <optional>
#include <set>
#include <vector>

#include "SDL_vulkan.h"
#include "imgui.h"
#include "imgui_impl_sdl2.h"
#include "imgui_impl_vulkan.h"

#include "log.hpp" // Utilizing existing log system
#define STB_TRUETYPE_IMPLEMENTATION
#include "imstb_truetype.h"
#include <math.h> // For tan, sqrt, etc.

// Shader headers (generated by build system)
const uint32_t aabb_vert_spv[] =
#include "aabb.vert.spv.h"
    ;

const uint32_t aabb_frag_spv[] =
#include "aabb.frag.spv.h"
    ;

const uint32_t text_vert_spv[] =
#include "text.vert.spv.h"
    ;

const uint32_t text_frag_spv[] =
#include "text.frag.spv.h"
    ;

namespace client {
namespace renderer {

// --- Internal Math ---
struct mat4_t {
  float m[16];

  static mat4_t identity() {
    return {{1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1}};
  }

  static mat4_t perspective(float fovy, float aspect, float n, float f) {
    float tanHalfFovy = tan(fovy / 2.0f);
    mat4_t res = {};
    res.m[0] = 1.0f / (aspect * tanHalfFovy);
    res.m[5] = 1.0f / (tanHalfFovy); // Vulkan clip Y is down? No, standard is Y
                                     // down in Vulkan if you don't flip.
    // GLM usually does Y up for OpenGL. Vulkan Y is down.
    // If we want +Y up in World, we need to handle that.
    // Let's stick thereto standard RH Y-down (Vulkan) or flip proj?
    // Standard Vulkan: Y points DOWN.
    // Our Camera logic (EditorState) seemed to assume Y up or similar?
    // EditorState: "Y up. sin(pitch) = y."
    // Let's flip Y in projection (m[5] *= -1) to match standard OpenGL-like
    // coords (Y-up) if desired.
    res.m[5] *= -1;

    res.m[10] = f / (n - f);
    res.m[11] = -1.0f;
    res.m[14] = -(f * n) / (f - n);
    return res;
  }

  static mat4_t ortho(float l, float r, float b, float t, float n, float f) {
    mat4_t res = identity();
    res.m[0] = 2.0f / (r - l);
    res.m[5] = 2.0f / (b - t); // Y Down
    res.m[10] = 1.0f / (n - f);
    res.m[12] = -(r + l) / (r - l);
    res.m[13] = -(b + t) / (b - t); // Y Down
    res.m[14] = n / (n - f);        // Vulkan [0,1] Z range
    return res;
  }

  static mat4_t lookat(float eyex, float eyey, float eyez, float centerx,
                       float centery, float centerz, float upx, float upy,
                       float upz) {
    // Z axis (Forward)
    float fx = centerx - eyex;
    float fy = centery - eyey;
    float fz = centerz - eyez;
    float rlen = 1.0f / sqrt(fx * fx + fy * fy + fz * fz);
    fx *= rlen;
    fy *= rlen;
    fz *= rlen;

    // X axis (Right) = f x up
    float rx = fy * upz - fz * upy;
    float ry = fz * upx - fx * upz;
    float rz = fx * upy - fy * upx;
    rlen = 1.0f / sqrt(rx * rx + ry * ry + rz * rz);
    rx *= rlen;
    ry *= rlen;
    rz *= rlen;

    // Y axis (Up) = r x f
    float ux = ry * fz - rz * fy;
    float uy = rz * fx - rx * fz;
    float uz = rx * fy - ry * fx;

    mat4_t res = identity();
    res.m[0] = rx;
    res.m[4] = ry;
    res.m[8] = rz;
    res.m[1] = ux;
    res.m[5] = uy;
    res.m[9] = uz;
    res.m[2] = -fx;
    res.m[6] = -fy;
    res.m[10] = -fz;
    res.m[12] = -(rx * eyex + ry * eyey + rz * eyez);
    res.m[13] = -(ux * eyex + uy * eyey + uz * eyez);
    res.m[14] = (fx * eyex + fy * eyey + fz * eyez);
    return res;
  }

  static mat4_t mult(const mat4_t &a, const mat4_t &b) {
    mat4_t res = {};
    for (int c = 0; c < 4; ++c) {
      for (int r = 0; r < 4; ++r) {
        res.m[c * 4 + r] = 0;
        for (int k = 0; k < 4; ++k) {
          res.m[c * 4 + r] += a.m[k * 4 + r] * b.m[c * 4 + k];
        }
      }
    }
    return res;
  }
};

static mat4_t g_current_view_proj;

// --- AABB Pipeline Globals ---
static VkPipelineLayout g_aabb_pipeline_layout = VK_NULL_HANDLE;
static VkPipeline g_aabb_pipeline = VK_NULL_HANDLE;
static VkBuffer g_aabb_vertex_buffer = VK_NULL_HANDLE;
static VkDeviceMemory g_aabb_vertex_memory = VK_NULL_HANDLE;
static VkBuffer g_aabb_index_buffer = VK_NULL_HANDLE;
static VkDeviceMemory g_aabb_index_memory = VK_NULL_HANDLE;

struct Vertex {
  float pos[3];
  float color[3];
  float bary[3];
};

struct PushConstants {
  float mvp[16];
  float color[4];
};

// --- Globals (Internal) ---

// Font State
struct FontState {
  stbtt_fontinfo info;
  unsigned char *ttf_buffer;
  unsigned char *bitmap;
  VkImage texture_image;
  VkDeviceMemory texture_memory;
  VkImageView texture_view;
  VkSampler sampler;
  stbtt_bakedchar cdata[96]; // ASCII 32..126 is 95 glyphs
  VkPipelineLayout pipeline_layout;
  VkPipeline pipeline;
  VkBuffer vertex_buffer;
  VkDeviceMemory vertex_memory;
  VkDescriptorSetLayout ds_layout;
  VkDescriptorSet descriptor_set;
};

static FontState g_font_state = {};

// Announcement State
static std::string g_announcement_text;
static uint64_t g_announcement_end_time = 0;

static SDL_Window *g_window = nullptr;
static VkInstance g_instance = VK_NULL_HANDLE;
static VkPhysicalDevice g_physical_device = VK_NULL_HANDLE;
static VkDevice g_device = VK_NULL_HANDLE;
static VkQueue g_graphics_queue = VK_NULL_HANDLE;
static VkQueue g_present_queue = VK_NULL_HANDLE;
static VkSurfaceKHR g_surface = VK_NULL_HANDLE;
static VkSwapchainKHR g_swapchain = VK_NULL_HANDLE;
static std::vector<VkImage> g_swapchain_images;
static std::vector<VkImageView> g_swapchain_image_views;
static VkFormat g_swapchain_image_format;
static VkExtent2D g_swapchain_extent;

static VkRenderPass g_render_pass = VK_NULL_HANDLE;
static VkDescriptorPool g_descriptor_pool = VK_NULL_HANDLE;
static VkCommandPool g_command_pool = VK_NULL_HANDLE;
static std::vector<VkFramebuffer> g_swapchain_framebuffers;
static std::vector<VkCommandBuffer> g_command_buffers;

static std::vector<VkSemaphore> g_image_available_semaphores;
static std::vector<VkSemaphore> g_render_finished_semaphores;
static std::vector<VkFence> g_in_flight_fences;

static uint32_t g_current_frame = 0;
const int MAX_FRAMES_IN_FLIGHT = 2;
static bool g_swapchain_rebuild = false;
static uint32_t g_image_index = 0; // Stored between BeginFrame and EndFrame

// --- Helper Functions ---

static void check_vk_result(VkResult err) {
  if (err == 0)
    return;
  log_error("[vulkan] Error: VkResult = {}", (int)err);
  if (err < 0)
    abort();
}

struct QueueFamilyIndices {
  std::optional<uint32_t> graphics_family;
  std::optional<uint32_t> present_family;

  bool is_complete() {
    return graphics_family.has_value() && present_family.has_value();
  }
};

static QueueFamilyIndices find_queue_families(VkPhysicalDevice device) {
  QueueFamilyIndices indices;
  uint32_t queue_family_count = 0;
  vkGetPhysicalDeviceQueueFamilyProperties(device, &queue_family_count,
                                           nullptr);
  std::vector<VkQueueFamilyProperties> queue_families(queue_family_count);
  vkGetPhysicalDeviceQueueFamilyProperties(device, &queue_family_count,
                                           queue_families.data());

  int i = 0;
  for (const auto &queue_family : queue_families) {
    if (queue_family.queueFlags & VK_QUEUE_GRAPHICS_BIT) {
      indices.graphics_family = i;
    }
    VkBool32 present_support = false;
    vkGetPhysicalDeviceSurfaceSupportKHR(device, i, g_surface,
                                         &present_support);
    if (present_support) {
      indices.present_family = i;
    }
    if (indices.is_complete())
      break;
    i++;
  }
  return indices;
}

static void cleanup_swapchain() {
  for (auto framebuffer : g_swapchain_framebuffers) {
    vkDestroyFramebuffer(g_device, framebuffer, nullptr);
  }
  for (auto imageView : g_swapchain_image_views) {
    vkDestroyImageView(g_device, imageView, nullptr);
  }
  vkDestroySwapchainKHR(g_device, g_swapchain, nullptr);
}

static void create_swapchain() {
  VkSurfaceCapabilitiesKHR capabilities;
  vkGetPhysicalDeviceSurfaceCapabilitiesKHR(g_physical_device, g_surface,
                                            &capabilities);

  uint32_t format_count;
  vkGetPhysicalDeviceSurfaceFormatsKHR(g_physical_device, g_surface,
                                       &format_count, nullptr);
  std::vector<VkSurfaceFormatKHR> formats(format_count);
  vkGetPhysicalDeviceSurfaceFormatsKHR(g_physical_device, g_surface,
                                       &format_count, formats.data());

  uint32_t present_mode_count;
  vkGetPhysicalDeviceSurfacePresentModesKHR(g_physical_device, g_surface,
                                            &present_mode_count, nullptr);
  std::vector<VkPresentModeKHR> present_modes(present_mode_count);
  vkGetPhysicalDeviceSurfacePresentModesKHR(
      g_physical_device, g_surface, &present_mode_count, present_modes.data());

  VkSurfaceFormatKHR surface_format = formats[0];
  for (const auto &available_format : formats) {
    if (available_format.format == VK_FORMAT_B8G8R8A8_SRGB &&
        available_format.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) {
      surface_format = available_format;
      break;
    }
  }

  VkPresentModeKHR present_mode = VK_PRESENT_MODE_FIFO_KHR;
  VkExtent2D extent;
  if (capabilities.currentExtent.width != UINT32_MAX) {
    extent = capabilities.currentExtent;
  } else {
    int width, height;
    SDL_Vulkan_GetDrawableSize(g_window, &width, &height);
    extent = {(uint32_t)width, (uint32_t)height};
  }

  uint32_t image_count = capabilities.minImageCount + 1;
  if (capabilities.maxImageCount > 0 &&
      image_count > capabilities.maxImageCount) {
    image_count = capabilities.maxImageCount;
  }

  VkSwapchainCreateInfoKHR create_info{};
  create_info.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;
  create_info.surface = g_surface;
  create_info.minImageCount = image_count;
  create_info.imageFormat = surface_format.format;
  create_info.imageColorSpace = surface_format.colorSpace;
  create_info.imageExtent = extent;
  create_info.imageArrayLayers = 1;
  create_info.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;

  QueueFamilyIndices indices = find_queue_families(g_physical_device);
  uint32_t queue_family_indices[] = {indices.graphics_family.value(),
                                     indices.present_family.value()};

  if (indices.graphics_family != indices.present_family) {
    create_info.imageSharingMode = VK_SHARING_MODE_CONCURRENT;
    create_info.queueFamilyIndexCount = 2;
    create_info.pQueueFamilyIndices = queue_family_indices;
  } else {
    create_info.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE;
  }

  create_info.preTransform = capabilities.currentTransform;
  create_info.compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;
  create_info.presentMode = present_mode;
  create_info.clipped = VK_TRUE;
  create_info.oldSwapchain = VK_NULL_HANDLE;

  if (vkCreateSwapchainKHR(g_device, &create_info, nullptr, &g_swapchain) !=
      VK_SUCCESS) {
    log_error("Failed to create swapchain!");
    return;
  }

  vkGetSwapchainImagesKHR(g_device, g_swapchain, &image_count, nullptr);
  g_swapchain_images.resize(image_count);
  vkGetSwapchainImagesKHR(g_device, g_swapchain, &image_count,
                          g_swapchain_images.data());

  g_swapchain_image_format = surface_format.format;
  g_swapchain_extent = extent;

  g_swapchain_image_views.resize(g_swapchain_images.size());
  for (size_t i = 0; i < g_swapchain_images.size(); i++) {
    VkImageViewCreateInfo create_info{};
    create_info.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
    create_info.image = g_swapchain_images[i];
    create_info.viewType = VK_IMAGE_VIEW_TYPE_2D;
    create_info.format = g_swapchain_image_format;
    create_info.components.r = VK_COMPONENT_SWIZZLE_IDENTITY;
    create_info.components.g = VK_COMPONENT_SWIZZLE_IDENTITY;
    create_info.components.b = VK_COMPONENT_SWIZZLE_IDENTITY;
    create_info.components.a = VK_COMPONENT_SWIZZLE_IDENTITY;
    create_info.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
    create_info.subresourceRange.baseMipLevel = 0;
    create_info.subresourceRange.levelCount = 1;
    create_info.subresourceRange.baseArrayLayer = 0;
    create_info.subresourceRange.layerCount = 1;

    if (vkCreateImageView(g_device, &create_info, nullptr,
                          &g_swapchain_image_views[i]) != VK_SUCCESS) {
      log_error("Failed to create image views!");
    }
  }
}

static void create_framebuffers() {
  g_swapchain_framebuffers.resize(g_swapchain_image_views.size());
  for (size_t i = 0; i < g_swapchain_image_views.size(); i++) {
    VkImageView attachments[] = {g_swapchain_image_views[i]};

    VkFramebufferCreateInfo framebuffer_info{};
    framebuffer_info.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
    framebuffer_info.renderPass = g_render_pass;
    framebuffer_info.attachmentCount = 1;
    framebuffer_info.pAttachments = attachments;
    framebuffer_info.width = g_swapchain_extent.width;
    framebuffer_info.height = g_swapchain_extent.height;
    framebuffer_info.layers = 1;

    if (vkCreateFramebuffer(g_device, &framebuffer_info, nullptr,
                            &g_swapchain_framebuffers[i]) != VK_SUCCESS) {
      log_error("Failed to create framebuffer!");
    }
  }
}

static void rebuild_swapchain() {
  int width = 0, height = 0;
  SDL_Vulkan_GetDrawableSize(g_window, &width, &height);
  if (width == 0 || height == 0)
    return;

  vkDeviceWaitIdle(g_device);
  cleanup_swapchain();
  create_swapchain();
  create_framebuffers();
}

// --- Internal AABB Functions ---

static uint32_t find_memory_type(uint32_t typeFilter,
                                 VkMemoryPropertyFlags properties) {
  VkPhysicalDeviceMemoryProperties memProperties;
  vkGetPhysicalDeviceMemoryProperties(g_physical_device, &memProperties);

  for (uint32_t i = 0; i < memProperties.memoryTypeCount; i++) {
    if ((typeFilter & (1 << i)) && (memProperties.memoryTypes[i].propertyFlags &
                                    properties) == properties) {
      return i;
    }
  }
  log_error("Failed to find suitable memory type!");
  return 0;
}

static void create_buffer(VkDeviceSize size, VkBufferUsageFlags usage,
                          VkMemoryPropertyFlags properties, VkBuffer &buffer,
                          VkDeviceMemory &bufferMemory) {
  VkBufferCreateInfo bufferInfo{};
  bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
  bufferInfo.size = size;
  bufferInfo.usage = usage;
  bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;

  if (vkCreateBuffer(g_device, &bufferInfo, nullptr, &buffer) != VK_SUCCESS) {
    log_error("failed to create buffer!");
    return;
  }

  VkMemoryRequirements memRequirements;
  vkGetBufferMemoryRequirements(g_device, buffer, &memRequirements);

  VkMemoryAllocateInfo allocInfo{};
  allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
  allocInfo.allocationSize = memRequirements.size;
  allocInfo.memoryTypeIndex =
      find_memory_type(memRequirements.memoryTypeBits, properties);

  if (vkAllocateMemory(g_device, &allocInfo, nullptr, &bufferMemory) !=
      VK_SUCCESS) {
    log_error("failed to allocate buffer memory!");
    return;
  }

  vkBindBufferMemory(g_device, buffer, bufferMemory, 0);
}

static void create_aabb_pipeline() {
  VkShaderModule vertShaderModule;
  VkShaderModule fragShaderModule;

  // Vert
  VkShaderModuleCreateInfo vertInfo{};
  vertInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
  vertInfo.codeSize = sizeof(aabb_vert_spv);
  vertInfo.pCode = aabb_vert_spv;
  if (vkCreateShaderModule(g_device, &vertInfo, nullptr, &vertShaderModule) !=
      VK_SUCCESS) {
    log_error("Failed to create vert shader module");
    return;
  }

  // Frag
  VkShaderModuleCreateInfo fragInfo{};
  fragInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
  fragInfo.codeSize = sizeof(aabb_frag_spv);
  fragInfo.pCode = aabb_frag_spv;
  if (vkCreateShaderModule(g_device, &fragInfo, nullptr, &fragShaderModule) !=
      VK_SUCCESS) {
    log_error("Failed to create frag shader module");
    return;
  }

  VkPipelineShaderStageCreateInfo shaderStages[] = {
      {VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, nullptr, 0,
       VK_SHADER_STAGE_VERTEX_BIT, vertShaderModule, "main", nullptr},
      {VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, nullptr, 0,
       VK_SHADER_STAGE_FRAGMENT_BIT, fragShaderModule, "main", nullptr}};

  // Vertex Input
  VkVertexInputBindingDescription bindingDescription{};
  bindingDescription.binding = 0;
  bindingDescription.stride = sizeof(Vertex);
  bindingDescription.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;

  VkVertexInputAttributeDescription attributeDescriptions[3]{};
  // Pos
  attributeDescriptions[0].binding = 0;
  attributeDescriptions[0].location = 0;
  attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
  attributeDescriptions[0].offset = offsetof(Vertex, pos);
  // Color
  attributeDescriptions[1].binding = 0;
  attributeDescriptions[1].location = 1;
  attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
  attributeDescriptions[1].offset = offsetof(Vertex, color);
  // Bary
  attributeDescriptions[2].binding = 0;
  attributeDescriptions[2].location = 2;
  attributeDescriptions[2].format = VK_FORMAT_R32G32B32_SFLOAT;
  attributeDescriptions[2].offset = offsetof(Vertex, bary);

  VkPipelineVertexInputStateCreateInfo vertexInputInfo{};
  vertexInputInfo.sType =
      VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
  vertexInputInfo.vertexBindingDescriptionCount = 1;
  vertexInputInfo.pVertexBindingDescriptions = &bindingDescription;
  vertexInputInfo.vertexAttributeDescriptionCount = 3;
  vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

  VkPipelineInputAssemblyStateCreateInfo inputAssembly{};
  inputAssembly.sType =
      VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
  inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
  inputAssembly.primitiveRestartEnable = VK_FALSE;

  // Viewport/Scissor (Dynamic)
  VkPipelineViewportStateCreateInfo viewportState{};
  viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
  viewportState.viewportCount = 1;
  viewportState.scissorCount = 1;

  VkPipelineRasterizationStateCreateInfo rasterizer{};
  rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
  rasterizer.depthClampEnable = VK_FALSE;
  rasterizer.rasterizerDiscardEnable = VK_FALSE;
  rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
  rasterizer.lineWidth = 1.0f;
  rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
  rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE; // CCW usually
  rasterizer.depthBiasEnable = VK_FALSE;

  VkPipelineMultisampleStateCreateInfo multisampling{};
  multisampling.sType =
      VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
  multisampling.sampleShadingEnable = VK_FALSE;
  multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

  // No Depth Test for now OR Enable it? Prompt didn't specify, but safer to
  // have it off for "overlay" or on for "world". Let's enable Z test but
  // disable write? Or just typical opaque. Let's do Standard Depth Test. Wait,
  // I need a depth buffer attachment for that! My current renderpass ONLY has
  // color attachment. So I cannot enable depth test unless I add depth buffer.
  // The user didn't ask for depth buffer setup yet.
  // I will DISABLE depth test for this draft.
  VkPipelineDepthStencilStateCreateInfo depthStencil{};
  depthStencil.sType =
      VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
  depthStencil.depthTestEnable = VK_FALSE;
  depthStencil.depthWriteEnable = VK_FALSE;
  depthStencil.depthCompareOp = VK_COMPARE_OP_LESS;
  // ...

  VkPipelineColorBlendAttachmentState colorBlendAttachment{};
  colorBlendAttachment.colorWriteMask =
      VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT |
      VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
  colorBlendAttachment.blendEnable = VK_TRUE;
  colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
  colorBlendAttachment.dstColorBlendFactor =
      VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
  colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;

  VkPipelineColorBlendStateCreateInfo colorBlending{};
  colorBlending.sType =
      VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
  colorBlending.logicOpEnable = VK_FALSE;
  colorBlending.attachmentCount = 1;
  colorBlending.pAttachments = &colorBlendAttachment;

  VkDynamicState dynamicStates[] = {VK_DYNAMIC_STATE_VIEWPORT,
                                    VK_DYNAMIC_STATE_SCISSOR};
  VkPipelineDynamicStateCreateInfo dynamicState{};
  dynamicState.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
  dynamicState.dynamicStateCount = 2;
  dynamicState.pDynamicStates = dynamicStates;

  // Push Constants
  VkPushConstantRange pushConstantRange{};
  pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
  pushConstantRange.offset = 0;
  pushConstantRange.size = sizeof(PushConstants);

  VkPipelineLayoutCreateInfo pipelineLayoutInfo{};
  pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
  pipelineLayoutInfo.setLayoutCount = 0;
  pipelineLayoutInfo.pushConstantRangeCount = 1;
  pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;

  if (vkCreatePipelineLayout(g_device, &pipelineLayoutInfo, nullptr,
                             &g_aabb_pipeline_layout) != VK_SUCCESS) {
    log_error("Failed to create pipeline layout!");
    return;
  }

  VkGraphicsPipelineCreateInfo pipelineInfo{};
  pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
  pipelineInfo.stageCount = 2;
  pipelineInfo.pStages = shaderStages;
  pipelineInfo.pVertexInputState = &vertexInputInfo;
  pipelineInfo.pInputAssemblyState = &inputAssembly;
  pipelineInfo.pViewportState = &viewportState;
  pipelineInfo.pRasterizationState = &rasterizer;
  pipelineInfo.pMultisampleState = &multisampling;
  pipelineInfo.pDepthStencilState = &depthStencil;
  pipelineInfo.pColorBlendState = &colorBlending;
  pipelineInfo.pDynamicState = &dynamicState;
  pipelineInfo.layout = g_aabb_pipeline_layout;
  pipelineInfo.renderPass = g_render_pass;
  pipelineInfo.subpass = 0;

  if (vkCreateGraphicsPipelines(g_device, VK_NULL_HANDLE, 1, &pipelineInfo,
                                nullptr, &g_aabb_pipeline) != VK_SUCCESS) {
    log_error("Failed to create graphics pipeline!");
  }

  vkDestroyShaderModule(g_device, fragShaderModule, nullptr);
  vkDestroyShaderModule(g_device, vertShaderModule, nullptr);
}

static void create_aabb_mesh() {
  // Unit Cube [-0.5, 0.5]
  // 24 vertices (4 per face), 36 indices
  float l = -0.5f;
  float h = 0.5f;

  std::vector<Vertex> vertices;
  std::vector<uint16_t> indices;
  uint16_t baseIndex = 0;

  // Helper to add face (4 verts, 2 tris)
  auto add_face = [&](float x1, float y1, float z1,   // BL
                      float x2, float y2, float z2,   // BR
                      float x3, float y3, float z3,   // TR
                      float x4, float y4, float z4) { // TL
    // Vertices with alternating Barycentrics
    vertices.push_back({{x1, y1, z1}, {1, 1, 1}, {1, 0, 0}}); // 0: Red
    vertices.push_back({{x2, y2, z2}, {1, 1, 1}, {0, 1, 0}}); // 1: Green
    vertices.push_back({{x3, y3, z3}, {1, 1, 1}, {0, 0, 1}}); // 2: Blue
    vertices.push_back({{x4, y4, z4}, {1, 1, 1}, {1, 0, 0}}); // 3: Red (Wrap)

    // Tri 1: 0-1-2
    indices.push_back(baseIndex + 0);
    indices.push_back(baseIndex + 1);
    indices.push_back(baseIndex + 2);

    // Tri 2: 0-2-3
    indices.push_back(baseIndex + 0);
    indices.push_back(baseIndex + 2);
    indices.push_back(baseIndex + 3);

    baseIndex += 4;
  };

  // Front (Z+)
  add_face(l, l, h, h, l, h, h, h, h, l, h, h);
  // Back (Z-) - Order reversed for CCW?
  // Z- face looking from back: TR(h,h,l), TL(l,h,l), BL(l,l,l), BR(h,l,l)
  // Standard View:
  add_face(h, l, l, l, l, l, l, h, l, h, h, l);

  // Left (X-)
  add_face(l, l, l, l, l, h, l, h, h, l, h, l);
  // Right (X+)
  add_face(h, l, h, h, l, l, h, h, l, h, h, h);
  // Top (Y+)
  add_face(l, h, h, h, h, h, h, h, l, l, h, l);
  // Bottom (Y-)
  add_face(l, l, l, h, l, l, h, l, h, l, l, h);

  // Vertex Buffer
  VkDeviceSize vSize = sizeof(Vertex) * vertices.size();
  VkBuffer vStaging;
  VkDeviceMemory vStagingMem;
  create_buffer(vSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
                VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |
                    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
                vStaging, vStagingMem);

  void *data;
  vkMapMemory(g_device, vStagingMem, 0, vSize, 0, &data);
  memcpy(data, vertices.data(), (size_t)vSize);
  vkUnmapMemory(g_device, vStagingMem);

  create_buffer(vSize,
                VK_BUFFER_USAGE_TRANSFER_DST_BIT |
                    VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,
                VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, g_aabb_vertex_buffer,
                g_aabb_vertex_memory);

  // Index Buffer
  VkDeviceSize iSize = sizeof(uint16_t) * indices.size();
  VkBuffer iStaging;
  VkDeviceMemory iStagingMem;
  create_buffer(iSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
                VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |
                    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
                iStaging, iStagingMem);

  vkMapMemory(g_device, iStagingMem, 0, iSize, 0, &data);
  memcpy(data, indices.data(), (size_t)iSize);
  vkUnmapMemory(g_device, iStagingMem);

  create_buffer(iSize,
                VK_BUFFER_USAGE_TRANSFER_DST_BIT |
                    VK_BUFFER_USAGE_INDEX_BUFFER_BIT,
                VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, g_aabb_index_buffer,
                g_aabb_index_memory);

  // Copy cmds
  VkCommandBufferAllocateInfo allocInfo{
      VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO};
  allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
  allocInfo.commandPool = g_command_pool;
  allocInfo.commandBufferCount = 1;

  VkCommandBuffer cmd;
  vkAllocateCommandBuffers(g_device, &allocInfo, &cmd);

  VkCommandBufferBeginInfo beginInfo{
      VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO};
  beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;
  vkBeginCommandBuffer(cmd, &beginInfo);

  VkBufferCopy vCopy{};
  vCopy.size = vSize;
  vkCmdCopyBuffer(cmd, vStaging, g_aabb_vertex_buffer, 1, &vCopy);

  VkBufferCopy iCopy{};
  iCopy.size = iSize;
  vkCmdCopyBuffer(cmd, iStaging, g_aabb_index_buffer, 1, &iCopy);

  vkEndCommandBuffer(cmd);

  VkSubmitInfo submitInfo{VK_STRUCTURE_TYPE_SUBMIT_INFO};
  submitInfo.commandBufferCount = 1;
  submitInfo.pCommandBuffers = &cmd;

  vkQueueSubmit(g_graphics_queue, 1, &submitInfo, VK_NULL_HANDLE);
  vkQueueWaitIdle(g_graphics_queue);

  vkFreeCommandBuffers(g_device, g_command_pool, 1, &cmd);
  vkDestroyBuffer(g_device, vStaging, nullptr);
  vkFreeMemory(g_device, vStagingMem, nullptr);
  vkDestroyBuffer(g_device, iStaging, nullptr);
  vkFreeMemory(g_device, iStagingMem, nullptr);
}

static void init_font() {
  // No-op
}
// --- Public API ---

void DrawAABB(VkCommandBuffer cmd, const linalg::vec3 &min,
              const linalg::vec3 &max, uint32_t color) {
  if (g_aabb_pipeline == VK_NULL_HANDLE)
    return;

  vkCmdBindPipeline(cmd, VK_PIPELINE_BIND_POINT_GRAPHICS, g_aabb_pipeline);

  VkBuffer vertexBuffers[] = {g_aabb_vertex_buffer};
  VkDeviceSize offsets[] = {0};
  vkCmdBindVertexBuffers(cmd, 0, 1, vertexBuffers, offsets);
  vkCmdBindIndexBuffer(cmd, g_aabb_index_buffer, 0, VK_INDEX_TYPE_UINT16);

  PushConstants pc{};

  // Model Matrix: Translate(Center) * Scale(Extent)
  float w = max.x - min.x;
  float h = max.y - min.y;
  float d = max.z - min.z;
  float cx = (min.x + max.x) * 0.5f;
  float cy = (min.y + max.y) * 0.5f;
  float cz = (min.z + max.z) * 0.5f;

  mat4_t model = mat4_t::identity();
  // Scale
  model.m[0] = w;
  model.m[5] = h;
  model.m[10] = d;
  // Translate
  model.m[12] = cx;
  model.m[13] = cy;
  model.m[14] = cz;

  // MVP = Proj * View * Model
  mat4_t mvp = mat4_t::mult(g_current_view_proj, model);

  // Copy to PC

  // Copy to PC
  memcpy(pc.mvp, mvp.m, sizeof(float) * 16);

  // Extract Color (ABGR format: 0xAABBGGRR)
  float a = ((color >> 24) & 0xFF) / 255.0f;
  float b = ((color >> 16) & 0xFF) / 255.0f;
  float g = ((color >> 8) & 0xFF) / 255.0f;
  float r = (color & 0xFF) / 255.0f;

  pc.color[0] = r;
  pc.color[1] = g;
  pc.color[2] = b;
  pc.color[3] = a;

  vkCmdPushConstants(cmd, g_aabb_pipeline_layout, VK_SHADER_STAGE_VERTEX_BIT, 0,
                     sizeof(PushConstants), &pc);

  // 36 indices
  vkCmdDrawIndexed(cmd, 36, 1, 0, 0, 0);
}

void draw_announcement(const char *text) {
  g_announcement_text = text;
  g_announcement_end_time = SDL_GetTicks64() + 3000;
}

void set_viewport(VkCommandBuffer cmd, const viewport_t &vp) {
  float x = vp.start.x * g_swapchain_extent.width;
  float y = vp.start.y * g_swapchain_extent.height;
  float w = vp.dimensions.x * g_swapchain_extent.width;
  float h = vp.dimensions.y * g_swapchain_extent.height;

  VkViewport v{};
  v.x = x;
  v.y = y;
  v.width = w;
  v.height = h;
  v.minDepth = 0.0f;
  v.maxDepth = 1.0f;

  vkCmdSetViewport(cmd, 0, 1, &v);

  VkRect2D scissor{};
  scissor.offset = {(int32_t)x, (int32_t)y};
  scissor.extent = {(uint32_t)w, (uint32_t)h};

  vkCmdSetScissor(cmd, 0, 1, &scissor);
}

void render_view(VkCommandBuffer cmd, const render_view_t &view,
                 const ecs::Registry &registry) {
  set_viewport(cmd, view.viewport);

  // Calculate VP Matrix
  float aspect = view.viewport.dimensions.x * g_swapchain_extent.width /
                 (view.viewport.dimensions.y * g_swapchain_extent.height);
  if (view.viewport.dimensions.y == 0)
    aspect = 1.0f;

  mat4_t proj;
  if (view.camera.orthographic) {
    float h = view.camera.ortho_height;
    float w = h * aspect;
    // Centered ortho (Left, Right, Bottom, Top, Near, Far)
    // We want Bottom < Top for standard Up-is-Up coordinate system in
    // World/View. Vulkan NDC: Y is Down (-1 Top, +1 Bottom). If we map World Y+
    // to NDC Y- (-1), we need Top to be positive Y? Standard mat4_t::ortho
    // (from linalg logic probably uses OpenGL convention -1..1 Y Up?) Let's
    // assume standard GL ortho: (L, R, B, T). If we want World Y Up -> NDC Y Up
    // (GL) -> Vulkan Y Down (flip via viewport or proj). Usually we just flip Y
    // in Viewport (negative height) or Proj. Here we swap bounds: Bottom=-h/2,
    // Top=+h/2.
    proj = mat4_t::ortho(-w * 0.5f, w * 0.5f, -h * 0.5f, h * 0.5f, -1000.0f,
                         1000.0f);
  } else {
    proj = mat4_t::perspective(1.5708f, aspect, 0.1f, 1000.0f); // 90 deg fov
  }

  // View Matrix from Camera
  float cx = view.camera.x;
  float cy = view.camera.y;
  float cz = view.camera.z;

  // Direction from Yaw/Pitch
  float radYaw = view.camera.yaw * 0.0174533f;
  float radPitch = view.camera.pitch * 0.0174533f;

  float cY = cos(radYaw);
  float sY = sin(radYaw);
  float cP = cos(radPitch);
  float sP = sin(radPitch);

  float fx = cY * cP;
  float fy = sP;
  float fz = sY * cP;

  mat4_t viewMat =
      mat4_t::lookat(cx, cy, cz, cx + fx, cy + fy, cz + fz, 0, 1, 0); // Y up

  g_current_view_proj = mat4_t::mult(proj, viewMat);

  // TODO: Use view.camera and render entities from registry
  // logic to iterate and draw would go here
  (void)registry; // unused for now
}

void ProcessEvent(const SDL_Event *event) {
  ImGui_ImplSDL2_ProcessEvent(event);
  if (event->type == SDL_WINDOWEVENT &&
      event->window.event == SDL_WINDOWEVENT_RESIZED &&
      event->window.windowID == SDL_GetWindowID(g_window)) {
    g_swapchain_rebuild = true;
  }
}

bool Init(SDL_Window *window) {
  g_window = window;

  // Vulkan Init
  unsigned int count;
  SDL_Vulkan_GetInstanceExtensions(g_window, &count, nullptr);
  std::vector<const char *> extensions(count);
  SDL_Vulkan_GetInstanceExtensions(g_window, &count, extensions.data());

  VkApplicationInfo app_info = {};
  app_info.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
  app_info.pApplicationName = "MyGame";
  app_info.applicationVersion = VK_MAKE_VERSION(1, 0, 0);
  app_info.pEngineName = "No Engine";
  app_info.engineVersion = VK_MAKE_VERSION(1, 0, 0);
  app_info.apiVersion = VK_API_VERSION_1_0;

  VkInstanceCreateInfo instance_info = {};
  instance_info.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
  instance_info.pApplicationInfo = &app_info;

#ifdef __APPLE__
  std::vector<const char *> appleExtensions = extensions;
  appleExtensions.push_back(VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME);
  instance_info.flags |= VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR;
  instance_info.enabledExtensionCount = (uint32_t)appleExtensions.size();
  instance_info.ppEnabledExtensionNames = appleExtensions.data();
#else
  instance_info.enabledExtensionCount = (uint32_t)extensions.size();
  instance_info.ppEnabledExtensionNames = extensions.data();
#endif

  if (vkCreateInstance(&instance_info, nullptr, &g_instance) != VK_SUCCESS) {
    log_error("Failed to create Vulkan instance!");
    return false;
  }
  log_terminal("Vulkan Instance created.");

  if (!SDL_Vulkan_CreateSurface(g_window, g_instance, &g_surface)) {
    log_error("Failed to create Vulkan surface: {}", SDL_GetError());
    return false;
  }

  // Physical Device
  uint32_t device_count = 0;
  vkEnumeratePhysicalDevices(g_instance, &device_count, nullptr);
  if (device_count == 0) {
    log_error("Failed to find GPUs with Vulkan support!");
    return false;
  }
  std::vector<VkPhysicalDevice> devices(device_count);
  vkEnumeratePhysicalDevices(g_instance, &device_count, devices.data());
  g_physical_device = devices[0];

  // Logical Device
  QueueFamilyIndices indices = find_queue_families(g_physical_device);
  std::vector<VkDeviceQueueCreateInfo> queue_create_infos;
  std::set<uint32_t> unique_queue_families = {indices.graphics_family.value(),
                                              indices.present_family.value()};

  float queue_priority = 1.0f;
  for (uint32_t queue_family : unique_queue_families) {
    VkDeviceQueueCreateInfo queue_create_info{};
    queue_create_info.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
    queue_create_info.queueFamilyIndex = queue_family;
    queue_create_info.queueCount = 1;
    queue_create_info.pQueuePriorities = &queue_priority;
    queue_create_infos.push_back(queue_create_info);
  }

  VkDeviceCreateInfo device_info{};
  device_info.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
  device_info.queueCreateInfoCount =
      static_cast<uint32_t>(queue_create_infos.size());
  device_info.pQueueCreateInfos = queue_create_infos.data();
  device_info.pEnabledFeatures = nullptr;

  const std::vector<const char *> device_extensions = {
      VK_KHR_SWAPCHAIN_EXTENSION_NAME};
  device_info.enabledExtensionCount =
      static_cast<uint32_t>(device_extensions.size());
  device_info.ppEnabledExtensionNames = device_extensions.data();

#ifdef __APPLE__
  std::vector<const char *> apple_device_extensions = device_extensions;
  apple_device_extensions.push_back("VK_KHR_portability_subset");
  device_info.enabledExtensionCount = (uint32_t)apple_device_extensions.size();
  device_info.ppEnabledExtensionNames = apple_device_extensions.data();
#endif

  if (vkCreateDevice(g_physical_device, &device_info, nullptr, &g_device) !=
      VK_SUCCESS) {
    log_error("Failed to create logical device!");
    return false;
  }

  vkGetDeviceQueue(g_device, indices.graphics_family.value(), 0,
                   &g_graphics_queue);
  vkGetDeviceQueue(g_device, indices.present_family.value(), 0,
                   &g_present_queue);

  // Descriptor Pool
  VkDescriptorPoolSize pool_sizes[] = {
      {VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, 1},
  };
  VkDescriptorPoolCreateInfo pool_info{};
  pool_info.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
  pool_info.flags = VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT;
  pool_info.maxSets = 1;
  pool_info.poolSizeCount = (uint32_t)std::size(pool_sizes);
  pool_info.pPoolSizes = pool_sizes;
  vkCreateDescriptorPool(g_device, &pool_info, nullptr, &g_descriptor_pool);

  create_swapchain();

  // Render Pass
  VkAttachmentDescription color_attachment{};
  color_attachment.format = g_swapchain_image_format;
  color_attachment.samples = VK_SAMPLE_COUNT_1_BIT;
  color_attachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
  color_attachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
  color_attachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
  color_attachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
  color_attachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
  color_attachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;

  VkAttachmentReference color_attachment_ref{};
  color_attachment_ref.attachment = 0;
  color_attachment_ref.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;

  VkSubpassDescription subpass{};
  subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
  subpass.colorAttachmentCount = 1;
  subpass.pColorAttachments = &color_attachment_ref;

  VkSubpassDependency dependency{};
  dependency.srcSubpass = VK_SUBPASS_EXTERNAL;
  dependency.dstSubpass = 0;
  dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
  dependency.srcAccessMask = 0;
  dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
  dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;

  VkRenderPassCreateInfo render_pass_info{};
  render_pass_info.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
  render_pass_info.attachmentCount = 1;
  render_pass_info.pAttachments = &color_attachment;
  render_pass_info.subpassCount = 1;
  render_pass_info.pSubpasses = &subpass;
  render_pass_info.dependencyCount = 1;
  render_pass_info.pDependencies = &dependency;

  if (vkCreateRenderPass(g_device, &render_pass_info, nullptr,
                         &g_render_pass) != VK_SUCCESS) {
    log_error("Failed to create render pass!");
    return false;
  }

  create_framebuffers();

  // Command Pool
  VkCommandPoolCreateInfo command_pool_info{};
  command_pool_info.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
  command_pool_info.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;
  command_pool_info.queueFamilyIndex = indices.graphics_family.value();
  if (vkCreateCommandPool(g_device, &command_pool_info, nullptr,
                          &g_command_pool) != VK_SUCCESS) {
    log_error("Failed to create command pool!");
    return false;
  }

  create_aabb_pipeline();
  create_aabb_mesh();

  g_command_buffers.resize(MAX_FRAMES_IN_FLIGHT);
  VkCommandBufferAllocateInfo alloc_info{};
  alloc_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
  alloc_info.commandPool = g_command_pool;
  alloc_info.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
  alloc_info.commandBufferCount = (uint32_t)g_command_buffers.size();

  if (vkAllocateCommandBuffers(g_device, &alloc_info,
                               g_command_buffers.data()) != VK_SUCCESS) {
    log_error("Failed to allocate command buffers!");
    return false;
  }

  // Sync Objects
  g_image_available_semaphores.resize(MAX_FRAMES_IN_FLIGHT);
  g_render_finished_semaphores.resize(MAX_FRAMES_IN_FLIGHT);
  g_in_flight_fences.resize(MAX_FRAMES_IN_FLIGHT);

  VkSemaphoreCreateInfo semaphore_info{};
  semaphore_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
  VkFenceCreateInfo fence_info{};
  fence_info.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
  fence_info.flags = VK_FENCE_CREATE_SIGNALED_BIT;

  for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
    if (vkCreateSemaphore(g_device, &semaphore_info, nullptr,
                          &g_image_available_semaphores[i]) != VK_SUCCESS ||
        vkCreateSemaphore(g_device, &semaphore_info, nullptr,
                          &g_render_finished_semaphores[i]) != VK_SUCCESS ||
        vkCreateFence(g_device, &fence_info, nullptr, &g_in_flight_fences[i]) !=
            VK_SUCCESS) {
      log_error("Failed to create sync objects!");
      return false;
    }
  }

  // ImGui
  IMGUI_CHECKVERSION();
  ImGui::CreateContext();
  ImGuiIO &io = ImGui::GetIO();
  (void)io;
  io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;
  io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;
  ImGui::StyleColorsDark();

  ImGui_ImplSDL2_InitForVulkan(g_window);
  ImGui_ImplVulkan_InitInfo init_info = {};
  init_info.Instance = g_instance;
  init_info.PhysicalDevice = g_physical_device;
  init_info.Device = g_device;
  init_info.QueueFamily = indices.graphics_family.value();
  init_info.Queue = g_graphics_queue;
  init_info.PipelineCache = VK_NULL_HANDLE;
  init_info.DescriptorPool = g_descriptor_pool;
  init_info.Subpass = 0;
  init_info.MinImageCount = MAX_FRAMES_IN_FLIGHT;
  init_info.ImageCount = MAX_FRAMES_IN_FLIGHT;
  init_info.MSAASamples = VK_SAMPLE_COUNT_1_BIT;
  init_info.Allocator = nullptr;
  init_info.CheckVkResultFn = check_vk_result;
  ImGui_ImplVulkan_Init(&init_info, g_render_pass);

  // Fonts
  {
    VkCommandBuffer command_buffer = g_command_buffers[0];
    vkResetCommandPool(g_device, g_command_pool, 0);
    VkCommandBufferBeginInfo begin_info = {};
    begin_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
    begin_info.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;
    vkBeginCommandBuffer(command_buffer, &begin_info);

    ImGui_ImplVulkan_CreateFontsTexture();

    vkEndCommandBuffer(command_buffer);
    VkSubmitInfo submit_info = {};
    submit_info.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
    submit_info.commandBufferCount = 1;
    submit_info.pCommandBuffers = &command_buffer;
    vkQueueSubmit(g_graphics_queue, 1, &submit_info, VK_NULL_HANDLE);
    vkDeviceWaitIdle(g_device);
    vkQueueSubmit(g_graphics_queue, 1, &submit_info, VK_NULL_HANDLE);
    vkDeviceWaitIdle(g_device);
  }

  init_font();

  return true;
}

void Shutdown() {
  vkDeviceWaitIdle(g_device);

  ImGui_ImplVulkan_Shutdown();
  ImGui_ImplSDL2_Shutdown();
  ImGui::DestroyContext();

  cleanup_swapchain();
  vkDestroyDescriptorPool(g_device, g_descriptor_pool, nullptr);

  // Font cleanup
  vkDestroyPipeline(g_device, g_font_state.pipeline, nullptr);
  vkDestroyPipelineLayout(g_device, g_font_state.pipeline_layout, nullptr);
  vkDestroyDescriptorSetLayout(g_device, g_font_state.ds_layout, nullptr);
  vkDestroyImageView(g_device, g_font_state.texture_view, nullptr);
  vkDestroyImage(g_device, g_font_state.texture_image, nullptr);
  vkFreeMemory(g_device, g_font_state.texture_memory, nullptr);
  vkDestroySampler(g_device, g_font_state.sampler, nullptr);
  vkDestroyBuffer(g_device, g_font_state.vertex_buffer, nullptr);
  vkFreeMemory(g_device, g_font_state.vertex_memory, nullptr);
  free(g_font_state.ttf_buffer);
  free(g_font_state.bitmap);

  for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
    vkDestroySemaphore(g_device, g_render_finished_semaphores[i], nullptr);
    vkDestroySemaphore(g_device, g_image_available_semaphores[i], nullptr);
    vkDestroyFence(g_device, g_in_flight_fences[i], nullptr);
  }

  vkDestroyCommandPool(g_device, g_command_pool, nullptr);
  vkDestroyPipeline(g_device, g_aabb_pipeline, nullptr);
  vkDestroyPipelineLayout(g_device, g_aabb_pipeline_layout, nullptr);
  vkDestroyBuffer(g_device, g_aabb_vertex_buffer, nullptr);
  vkFreeMemory(g_device, g_aabb_vertex_memory, nullptr);
  vkDestroyBuffer(g_device, g_aabb_index_buffer, nullptr);
  vkFreeMemory(g_device, g_aabb_index_memory, nullptr);

  vkDestroyRenderPass(g_device, g_render_pass, nullptr);
  vkDestroyDevice(g_device, nullptr);

  if (g_surface) {
    vkDestroySurfaceKHR(g_instance, g_surface, nullptr);
  }
  if (g_instance) {
    vkDestroyInstance(g_instance, nullptr);
  }
  // Window is destroyed by client_impl (or passed in) but client_impl owns it?
  // Our Init took SDL_Window*, so we don't own it.
}

VkCommandBuffer BeginFrame() {
  if (g_swapchain_rebuild) {
    rebuild_swapchain();
    g_swapchain_rebuild = false;
  }

  vkWaitForFences(g_device, 1, &g_in_flight_fences[g_current_frame], VK_TRUE,
                  UINT64_MAX);

  VkResult result =
      vkAcquireNextImageKHR(g_device, g_swapchain, UINT64_MAX,
                            g_image_available_semaphores[g_current_frame],
                            VK_NULL_HANDLE, &g_image_index);

  if (result == VK_ERROR_OUT_OF_DATE_KHR) {
    g_swapchain_rebuild = true;
    return VK_NULL_HANDLE;
  } else if (result != VK_SUCCESS && result != VK_SUBOPTIMAL_KHR) {
    log_error("Failed to acquire swap chain image!");
    return VK_NULL_HANDLE;
  }

  vkResetFences(g_device, 1, &g_in_flight_fences[g_current_frame]);

  vkResetCommandBuffer(g_command_buffers[g_current_frame], 0);
  VkCommandBuffer cmdbuf = g_command_buffers[g_current_frame];

  VkCommandBufferBeginInfo begin_info{};
  begin_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
  if (vkBeginCommandBuffer(cmdbuf, &begin_info) != VK_SUCCESS) {
    log_error("Failed to begin command buffer!");
    return VK_NULL_HANDLE;
  }

  ImGui_ImplVulkan_NewFrame();
  ImGui_ImplSDL2_NewFrame();
  ImGui::NewFrame();

  return cmdbuf;
}

void BeginRenderPass(VkCommandBuffer cmd) {
  VkRenderPassBeginInfo render_pass_info{};
  render_pass_info.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
  render_pass_info.renderPass = g_render_pass;
  render_pass_info.framebuffer = g_swapchain_framebuffers[g_image_index];
  render_pass_info.renderArea.offset = {0, 0};
  render_pass_info.renderArea.extent = g_swapchain_extent;

  VkClearValue clear_color = {{{0.1f, 0.1f, 0.1f, 1.0f}}};
  render_pass_info.clearValueCount = 1;
  render_pass_info.pClearValues = &clear_color;

  vkCmdBeginRenderPass(cmd, &render_pass_info, VK_SUBPASS_CONTENTS_INLINE);
}

static void render_announcement(VkCommandBuffer cmd) {
  if (g_font_state.pipeline == VK_NULL_HANDLE) {
    // Fallback or just ignore check if we use ImGui
  }
  if (SDL_GetTicks64() >= g_announcement_end_time ||
      g_announcement_text.empty())
    return;

  // Use ImGui to render text (Simple, Robust, No Dependencies)
  // Use ImGui display size to handle High-DPI correctly
  ImVec2 center = ImGui::GetMainViewport()->GetCenter();

  // Set position to center
  ImGui::SetNextWindowPos(center, ImGuiCond_Always, ImVec2(0.5f, 0.5f));

  // Transparent, no-decoration window
  ImGui::SetNextWindowBgAlpha(0.0f);
  if (ImGui::Begin("AnnouncementOverlay", nullptr,
                   ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize |
                       ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoScrollbar |
                       ImGuiWindowFlags_NoSavedSettings |
                       ImGuiWindowFlags_NoInputs |
                       ImGuiWindowFlags_AlwaysAutoResize)) {
    ImGui::SetWindowFontScale(2.0f); // Make text larger
    ImGui::TextColored(ImVec4(1, 1, 1, 1), "%s", g_announcement_text.c_str());
  }
  ImGui::End();
}

void EndFrame(VkCommandBuffer cmd) {
  render_announcement(cmd);

  ImGui::Render();
  ImDrawData *draw_data = ImGui::GetDrawData();

  ImGui_ImplVulkan_RenderDrawData(draw_data, cmd);
  vkCmdEndRenderPass(cmd);

  if (vkEndCommandBuffer(cmd) != VK_SUCCESS) {
    log_error("Failed to record command buffer!");
    return;
  }

  VkSubmitInfo submit_info{};
  submit_info.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;

  VkSemaphore wait_semaphores[] = {
      g_image_available_semaphores[g_current_frame]};
  VkPipelineStageFlags wait_stages[] = {
      VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT};
  submit_info.waitSemaphoreCount = 1;
  submit_info.pWaitSemaphores = wait_semaphores;
  submit_info.pWaitDstStageMask = wait_stages;

  submit_info.commandBufferCount = 1;
  submit_info.pCommandBuffers = &cmd;

  VkSemaphore signal_semaphores[] = {
      g_render_finished_semaphores[g_current_frame]};
  submit_info.signalSemaphoreCount = 1;
  submit_info.pSignalSemaphores = signal_semaphores;

  if (vkQueueSubmit(g_graphics_queue, 1, &submit_info,
                    g_in_flight_fences[g_current_frame]) != VK_SUCCESS) {
    log_error("Failed to submit draw command buffer!");
    return;
  }

  VkPresentInfoKHR present_info{};
  present_info.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
  present_info.waitSemaphoreCount = 1;
  present_info.pWaitSemaphores = signal_semaphores;

  VkSwapchainKHR swapchains[] = {g_swapchain};
  present_info.swapchainCount = 1;
  present_info.pSwapchains = swapchains;
  present_info.pImageIndices = &g_image_index;

  VkResult result = vkQueuePresentKHR(g_present_queue, &present_info);

  if (result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR) {
    g_swapchain_rebuild = true;
  } else if (result != VK_SUCCESS) {
    log_error("Failed to present swap chain image!");
  }

  g_current_frame = (g_current_frame + 1) % MAX_FRAMES_IN_FLIGHT;
}

VkDevice GetDevice() { return g_device; }

} // namespace renderer
} // namespace client
